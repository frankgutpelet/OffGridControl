#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 29, 2024 03:50:46 PM CET  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import OffgridSim
from Settings import Settings
from OffGridControlRunner import OffGridControlRunner
import threading
from IInverter import IInverter
from IFrontend import IFrontend
import json
_debug = True # False to eliminate debug printing from callback functions.
lables : list
settings : Settings
runner : OffGridControlRunner
chargingmode = tk.StringVar
supply = tk.StringVar

class Logger:
    def __init__(self, window):
        self.window = window
    def Debug(self, text):
        self.window.insert(tk.END, "DEBUG - " + text + "\n")
    def Error(self, text):
        self.window.insert(tk.END, "ERROR - " + text + "\n")

class InverterSim (IInverter):
    #'batV', 'batI', 'solV', 'todayE', 'yesterdayE', 'supply', 'charchingstate'
    def __init__(self, batV : tk.Text, batI : tk.Text, solV : tk.Text, chargingmode : tk.Text, supply : tk.Text):
        self.batV = batV
        self.batI = batI
        self.solV = solV
        self.chargingmode = chargingmode
        self.supply = supply

    def getChargerData(self):

        return {'batV' : float(self.batV.get(1.0, tk.END)), 'batI' : float(self.batI.get(1.0, tk.END)), 'solV' : float(self.solV.get(1.0, tk.END)), 'supply' : self.supply.get(), 'chargingstate' : self.chargingmode.get(), 'yesterdayE' : 0, 'todayE' : 0}

class FrontendMock(IFrontend):
        transferDataGlobal = {'batV', 'batI', 'solV', 'todayE', 'yesterdayE', 'supply', 'chargingstate'}
        transferDataDevice = {'name', 'state', 'mode', 'ontime'}
        transferDataList : dict

        lastData : str

        def __init__(self, fifo, logger):
            self.logger = logger
            self.lastData = str()
            self.transferDataList = dict()
            self.transferDataList['Device'] = dict()
            pass

        def updateDevice(self, transferData: list):
            self.transferDataList['Device'][transferData['name']] = transferData

        def updateGlobalData(self, transferData: dict):
            for glob in transferData:
                self.transferDataList[glob] = transferData[glob]

        def sendData(self):
            iterator = 0
            for device in self.transferDataList['Device']:
                lables[iterator][0]['text'] = device
                lables[iterator][2]['text'] = self.transferDataList['Device'][device]['state']
                lables[iterator][1]['text'] = self.transferDataList['Device'][device]['mode']
                iterator += 1


def main(*args):
    '''Main entry point for the application.'''
    global root, Thread, logger, inverter, runner, frontend
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = OffgridSim.Toplevel1(_top1)
    init()
    readSettings()
    logger = Logger(_w1.TextLogging)
    inverter = InverterSim( _w1.TextBatV, _w1.BatI, _w1.TextSolV, _w1.chargingmode, _w1.supply)
    frontend = FrontendMock(None, logger)
    runner = OffGridControlRunner("config.xml", logger, inverter, frontend, simMode=True)
    Thread = threading.Thread(target=ThreadProc, args=())
    Thread.start()
    #Thread2 = threading.Thread(target=updateGui, args=())
    #Thread2.start()
    root.mainloop()

def readSettings():
    global settings
    settings = Settings("config.xml")
   # iterator = 0

    #for device in settings.approvals:
     #   lables[iterator][0]['text'] = device.name
      #  lables[iterator][1]['text'] = device.mode
       # iterator +=1

def init():
    global lables, chargingmode, supply
    lables = [ [_w1.LabelDev1, _w1.LabelMode1, _w1.LabelState1],
               [_w1.LabelDev2, _w1.LabelMode2, _w1.LabelState2],
               [_w1.LabelDev3, _w1.LabelMode3, _w1.LabelState3],
               [_w1.LabelDev4, _w1.LabelMode4, _w1.LabelState4],
               [_w1.LabelDev5, _w1.LabelMode5, _w1.LabelState5],
               [_w1.LabelDev6, _w1.LabelMode6, _w1.LabelState6],
               [_w1.LabelDev7, _w1.LabelMode7, _w1.LabelState7],
               [_w1.LabelDev8, _w1.LabelMode8, _w1.LabelState8],
               [_w1.LabelDev9, _w1.LabelMode9, _w1.LabelState9]]

    for line in lables:
        for entry in line:
            entry['text'] = ""
            entry.place(width = 160)
    _w1.supply.set("Utility")
    _w1.chargingmode.set("Bulk")
    _w1.TextBatV.insert("1.0", "24.0")
    _w1.BatI.insert("1.0", "0")
    _w1.TextSolV.insert("1.0", "60.0")


def ButtonSolVDownPressed(e):
    solV = round(float(_w1.TextSolV.get(1.0, tk.END)) - 0.1, 1)
    if 0 > solV:
        solV = 0
    _w1.TextSolV.delete("1.0", tk.END)
    _w1.TextSolV.insert("1.0", str(solV))

def ButtonSolVUpPressed(e):
    solV = round(float(_w1.TextSolV.get(1.0, tk.END)) + 0.1, 1)
    if 0 > solV:
        solV = 0
    _w1.TextSolV.delete("1.0", tk.END)
    _w1.TextSolV.insert("1.0", str(solV))

def ButtonBatVDownPressed(e):
    solV = round(float(_w1.TextBatV.get(1.0, tk.END)) - 0.1, 1)
    if 0 > solV:
        solV = 0
    _w1.TextBatV.delete("1.0", tk.END)
    _w1.TextBatV.insert("1.0", str(solV))

def ButtonBatVUpPressed(e):
    solV = round(float(_w1.TextBatV.get(1.0, tk.END)) + 0.1, 1)
    if 0 > solV:
        solV = 0
    _w1.TextBatV.delete("1.0", tk.END)
    _w1.TextBatV.insert("1.0", str(solV))

def ButtonBatIDownPressed(e):
    solV = round(float(_w1.BatI.get(1.0, tk.END)) - 1, 1)
    if 0 > solV:
        solV = 0
    _w1.BatI.delete("1.0", tk.END)
    _w1.BatI.insert("1.0", str(solV))

def ButtonBatIUpPressed(e):
    solV = round(float(_w1.BatI.get(1.0, tk.END)) + 1, 1)
    if 0 > solV:
        solV = 0
    _w1.BatI.delete("1.0", tk.END)
    _w1.BatI.insert("1.0", str(solV))

def ButtonFrontendTextPressed(e):
    global logger, frontend
    logger.Debug(json.dumps(frontend.transferDataList))




def ThreadProc():
    runner.run()

def updateGui():
    global settings, runner

    while(True):
        iterator = 0
        for device in settings.approvals:
            for consumer in runner.manager.consumers:
                if consumer.name == device.name:
                    if consumer.isOn:
                        lables[iterator][2]['text'] = "On"
                    else:
                        lables[iterator][2]['text'] = "Off"

            iterator += 1


if __name__ == '__main__':
    OffgridSim.start_up()




